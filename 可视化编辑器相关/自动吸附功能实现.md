## 自动吸附功能

### 功能目标

- 当用户在画布中拖动某一组件时，组件的某些关键点位置与相邻的兄弟元素或者父元素的关键点位置相近，则直接吸附到对应位置



### 实现思路

- 关键点梳理：每个组件都有五个关键点，上左 上右 下左 下右 中心点

- 吸附条件：当前拖动组件与所有关键点的x或者y值的差值，当差值小于阈值时，就进行吸附

- 吸附操作详细分析：鼠标移动事件发生时记录当前光标位置（`currentPos`），计算与初始位置的偏移量，根据偏移量计算 `currentDom` 元素的新位置信息，对比相关的关键点坐标，如果 x 或者 y 的差值小于阈值，则将该值设置为与对应坐标相应值一致。

### 代码示例


``` html
<!DOCTYPE html>
<html>
<head>
<style>
#div1 {
  border: 1px solid #ddd;
  position: absolute;
  top: 50px;
  left: 50px;
  width: 100px;
  height: 100px;
  text-align: center;
}

#div2 {
  border: 1px solid #ddd;
  position: absolute;
  top: 350px;
  left: 350px;
  width: 100px;
  height: 100px;
  text-align: center;
}
</style>
<script>
    window.onload = () => {
        const div1Dom = document.getElementById('div1');
        const div2Dom = document.getElementById('div2');
        const dragInfo = {
            isDraging: false
        }
        // 吸附阈值
        const dis = 16;
        div1.addEventListener('mousedown', e => {
            dragInfo.isDraging = true;
            dragInfo.startMousePos = {
                x: e.clientX,
                y: e.clientY,
            }
            dragInfo.startDomPos = {
                left: parseInt(window.getComputedStyle(div1Dom).left),
                top: parseInt(window.getComputedStyle(div1Dom).top),
            }
            dragInfo.startRect = div1Dom.getBoundingClientRect();
            const relateRect = div2Dom.getBoundingClientRect();
            dragInfo.relatePoints = [
                { position: 'TL', y: relateRect.top, x: relateRect.left },
                { position: 'TR', y: relateRect.top, x: relateRect.left + relateRect.width },
                { position: 'BL', y: relateRect.top + relateRect.height, x: relateRect.left},
                { position: 'BR', y: relateRect.top + relateRect.height, x: relateRect.left + relateRect.width },
            ]
            
            document.addEventListener('mousemove', onMove)
        })
        const onMove = e => {
            if (dragInfo.isDraging) {
                requestAnimationFrame(() => {
                    const offSetX = e.clientX - dragInfo.startMousePos.x;
                    const offSetY = e.clientY - dragInfo.startMousePos.y;
                    div1Dom.style.top = `${dragInfo.startDomPos.top + offSetY}px`;
                    div1Dom.style.left = `${dragInfo.startDomPos.left + offSetX}px`;
                    // 自动吸附
                    const currentRect = div1Dom.getBoundingClientRect();
                    const domPoints = [
                        { position: 'TL', y: currentRect.top, x: currentRect.left },
                        { position: 'TR', y: currentRect.top, x: currentRect.left + currentRect.width },
                        { position: 'BL', y: currentRect.top + currentRect.height, x: currentRect.left},
                        { position: 'BR', y: currentRect.top + currentRect.height, x: currentRect.left + currentRect.width },
                    ]
                    let getOne = false;
                    const newOffset = { x:0, y:0 };
                    let idx1 = 0
                    while (idx1 < domPoints.length) {
                        const p = domPoints[idx1];
                        const maxX = p.x + dis;
                        const maxY = p.y + dis;
                        const minX = p.x - dis;
                        const minY = p.y - dis;
                        let idx2 = 0;
                        while(idx2 < dragInfo.relatePoints.length) {
                            const point = dragInfo.relatePoints[idx2];
                            if (point.x > minX && point.x < maxX) {
                                newOffset.x = point.x - p.x;
                                getOne = true;
                            }
                            if (point.y > minY && point.y < maxY) {
                                newOffset.y = point.y - p.y;
                                getOne = true;
                            }
                            idx2 += 1;
                        }
                        idx1 += 1;
                    }
                    if (newOffset.x !== 0 || newOffset.y !== 0) {
                        div1Dom.style.top = `${dragInfo.startDomPos.top + newOffset.y + offSetY }px`;
                        div1Dom.style.left = `${dragInfo.startDomPos.left + newOffset.x + offSetX }px`;
                    }
                })
            }
        }
        document.addEventListener('mouseup', e => {
            if (dragInfo.isDraging) {
                requestAnimationFrame(() => {
                    dragInfo.isDraging = false; 
                    document.removeEventListener('mousemove', onMove);
                })
            }
        })
    }
</script>
</head>
<body>

<div id="div1">div1</div>

<div id="div2">div2</div>
</body>
</html>
 
``` 

