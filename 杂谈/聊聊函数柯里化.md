## 什么是函数柯里化？
柯里化通常也称部分求值，其含义是给函数分步传递参数，每次传递参数后,部分应用参数，并返回一个更具体的函数接受剩下的参数，中间可嵌套多层这样的接受部分参数函数，逐步缩小函数的适用范围，逐步求解,直至返回最后结果。

### 标准定义
> 是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。^[[wikipedia](https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96)]

*简而言之：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。*

### 命名来历：

柯里化的名称（curry）源自于 逻辑学家 Haskell Brooks Curry。 三个编程语言Haskell、Brook、Curry，以及柯里化的概念都是以他的名字来命名的。



## 看一个简单的例子：

``` 

// 常规写法
function add (a, b) { 
    return a + b
};

// add的柯里化写法
function addCurry (a) {
    return function (b) {
        return a + b
    }
}

add(5, 8);
// 13

addCurry(5)(8)
// 13

var addFive = addCurry(5);

addFive(8)
// 13 
``` 





### 扩展思考：
下面的代码实现了任意次数的累加调用，想想其中是什么原理？^[[相关讨论见：https://www.zhihu.com/question/20175380/answer/14223550](https://www.zhihu.com/question/20175380/answer/14223550)]

``` 

function add( seed ) {
    function retVal( later ) {
        return add( seed + later );
    }
    retVal.toString = function() {
        return seed;
    };
    return retVal;
}
console.log(add(1)(2)(3).toString()); 
// 6 
``` 


## 常见的柯里化应用实例

**redux connect**

Plain Text

``` 
connect(mapStateToProps, mapDispatchToProps, mergeProps)(MyComponent) 
``` 



**Function.prototype.bind**


``` 
function add (a, b) { 
    return a + b
};

var bindVersionAddFive = add.bind(this, 5) 

bindVersionAddFive(8)

// 13 
``` 

## 方便的辅助函数

lodash


``` 

fetch('https://cdn.jsdelivr.net/npm/lodash@4.17.4/lodash.min.js')
    .then(response => response.text())
    .then(text => eval(text))

Plain Text
var abc = function(a, b, c) {
  return [a, b, c];
};
 
var curried = _.curry(abc);
 
curried(1)(2)(3);
// => [1, 2, 3]
 
curried(1, 2)(3);
// => [1, 2, 3]
 
curried(1, 2, 3);
// => [1, 2, 3]
 
// Curried with placeholders.
curried(1)(_, 3)(2);
// => [1, 2, 3] 
``` 



## 自己动手实现


``` 

function curry(fn, args) {
    var length = fn.length;

    args = args || [];

    return function() {

        var _args = args.slice(0),

            arg, i;

        for (i = 0; i < arguments.length; i++) {

            arg = arguments[i];

            _args.push(arg);

        }
        if (_args.length < length) {
            return curry.call(this, fn, _args);
        }
        else {
            return fn.apply(this, _args);
        }
    }
}


var fn = curry(function(a, b, c) {
    console.log([a, b, c]);
});

 
``` 

